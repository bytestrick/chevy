Index: src/chevy/view/entities/animated/trap/SpikedFloorView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chevy.view.entities.animated.trap;\n\nimport chevy.model.entity.stateMachine.CommonState;\nimport chevy.model.entity.staticEntity.environment.traps.SpikedFloor;\nimport chevy.utils.Vector2;\nimport chevy.view.animation.AnimatedSprite;\nimport chevy.view.entities.animated.AnimatedEntityView;\n\nimport java.awt.image.BufferedImage;\n\npublic class SpikedFloorView extends AnimatedEntityView {\n    private static final String SPIKED_FLOOR_PATH = \"/assets/traps/spikedFloor/\";\n    private final SpikedFloor spikedFloor;\n\n    public SpikedFloorView(SpikedFloor spikedFloor) {\n        this.spikedFloor = spikedFloor;\n        this.currentViewPosition = new Vector2<>((double) spikedFloor.getCol(), (double) spikedFloor.getRow());\n\n        initAnimation();\n    }\n\n    private void initAnimation() {\n        Vector2<Integer> offset = new Vector2<>(0, -7);\n        createAnimation(SpikedFloor.EnumState.DISABLED, 0, 1,\n                spikedFloor.getState(SpikedFloor.EnumState.DISABLED).getDuration(), offset, 1, SPIKED_FLOOR_PATH +\n                        \"disabled\", \".png\");\n\n        createAnimation(SpikedFloor.EnumState.ACTIVATED, 0, 2,\n                spikedFloor.getState(SpikedFloor.EnumState.ACTIVATED).getDuration(), offset, 1, SPIKED_FLOOR_PATH +\n                        \"active\", \".png\");\n\n        createAnimation(SpikedFloor.EnumState.DAMAGE, 0, 1,\n                spikedFloor.getState(SpikedFloor.EnumState.DAMAGE).getDuration(), offset, 1, SPIKED_FLOOR_PATH +\n                        \"damage\", \".png\");\n    }\n\n    public Vector2<Integer> getOffset() {\n        CommonState currentState = spikedFloor.getCurrentState();\n        AnimatedSprite currentAnimatedSprite = this.getAnimatedSprite(currentState, 0);\n        return currentAnimatedSprite.getOffset();\n    }\n\n    @Override\n    public BufferedImage getCurrentFrame() {\n        CommonState currentEnumState = spikedFloor.getCurrentState();\n        AnimatedSprite currentAnimatedSprite = this.getAnimatedSprite(currentEnumState, 0);\n\n        if (currentAnimatedSprite != null) {\n            if (!currentAnimatedSprite.isRunning()) {\n                currentAnimatedSprite.restart();\n            }\n            return currentAnimatedSprite.getCurrentFrame();\n        }\n        return null;\n    }\n\n    @Override\n    public Vector2<Double> getCurrentViewPosition() {\n        return currentViewPosition;\n    }\n\n    @Override\n    public void wasRemoved() {\n        super.deleteAnimations();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/chevy/view/entities/animated/trap/SpikedFloorView.java b/src/chevy/view/entities/animated/trap/SpikedFloorView.java
--- a/src/chevy/view/entities/animated/trap/SpikedFloorView.java	(revision 97aac084825363cf2459bede42d8713076ad3645)
+++ b/src/chevy/view/entities/animated/trap/SpikedFloorView.java	(date 1723037508228)
@@ -21,17 +21,15 @@
 
     private void initAnimation() {
         Vector2<Integer> offset = new Vector2<>(0, -7);
-        createAnimation(SpikedFloor.EnumState.DISABLED, 0, 1,
-                spikedFloor.getState(SpikedFloor.EnumState.DISABLED).getDuration(), offset, 1, SPIKED_FLOOR_PATH +
-                        "disabled", ".png");
+        
+        final float disabledDuration = spikedFloor.getState(SpikedFloor.State.DISABLED).getDuration();
+        createAnimation(SpikedFloor.State.DISABLED, 0, 1, disabledDuration, offset, 1, SPIKED_FLOOR_PATH + "disabled", ".png");
 
-        createAnimation(SpikedFloor.EnumState.ACTIVATED, 0, 2,
-                spikedFloor.getState(SpikedFloor.EnumState.ACTIVATED).getDuration(), offset, 1, SPIKED_FLOOR_PATH +
-                        "active", ".png");
+        final float activatedDuration = spikedFloor.getState(SpikedFloor.State.ACTIVATED).getDuration();
+        createAnimation(SpikedFloor.State.ACTIVATED, 0, 2, activatedDuration, offset, 1, SPIKED_FLOOR_PATH + "active", ".png");
 
-        createAnimation(SpikedFloor.EnumState.DAMAGE, 0, 1,
-                spikedFloor.getState(SpikedFloor.EnumState.DAMAGE).getDuration(), offset, 1, SPIKED_FLOOR_PATH +
-                        "damage", ".png");
+        final float damageDuration = spikedFloor.getState(SpikedFloor.State.DAMAGE).getDuration();
+        createAnimation(SpikedFloor.State.DAMAGE, 0, 1, damageDuration, offset, 1, SPIKED_FLOOR_PATH + "damage", ".png");
     }
 
     public Vector2<Integer> getOffset() {
@@ -42,8 +40,8 @@
 
     @Override
     public BufferedImage getCurrentFrame() {
-        CommonState currentEnumState = spikedFloor.getCurrentState();
-        AnimatedSprite currentAnimatedSprite = this.getAnimatedSprite(currentEnumState, 0);
+        CommonState currentState = spikedFloor.getCurrentState();
+        AnimatedSprite currentAnimatedSprite = this.getAnimatedSprite(currentState, 0);
 
         if (currentAnimatedSprite != null) {
             if (!currentAnimatedSprite.isRunning()) {
Index: src/chevy/model/entity/dinamicEntity/projectile/Projectile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chevy.model.entity.dinamicEntity.projectile;\n\nimport chevy.model.entity.CommonEntityType;\nimport chevy.model.entity.dinamicEntity.DirectionsModel;\nimport chevy.model.entity.dinamicEntity.DynamicEntity;\nimport chevy.model.entity.stateMachine.CommonState;\nimport chevy.utils.Vector2;\n\npublic abstract class Projectile extends DynamicEntity {\n    private final Type type;\n    private final DirectionsModel direction;\n    private boolean collision = false;\n\n    public Projectile(Vector2<Integer> initPosition, Type type, DirectionsModel direction) {\n        super(initPosition, DynamicEntity.Type.PROJECTILE);\n\n        this.type = type;\n        this.direction = direction;\n        this.crossable = true;\n        this.safeToCross = false;\n        this.drawLayer = 1;\n    }\n\n    public boolean isCollision() { return collision; }\n\n    public void setCollision(boolean collision) { this.collision = collision; }\n\n    public DirectionsModel getDirection() { return direction; }\n\n    @Override\n    public CommonEntityType getSpecificType() { return type; }\n\n    @Override\n    public CommonEntityType getGenericType() { return super.getSpecificType(); }\n\n    @Override\n    public String toString() { return \"PROJECTILE\"; }\n\n    public enum Type implements CommonEntityType {\n        ARROW, FIRE_BALL, SLIME_SHOT;\n    }\n\n    public enum State implements CommonState {\n        START, LOOP, END;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/chevy/model/entity/dinamicEntity/projectile/Projectile.java b/src/chevy/model/entity/dinamicEntity/projectile/Projectile.java
--- a/src/chevy/model/entity/dinamicEntity/projectile/Projectile.java	(revision 97aac084825363cf2459bede42d8713076ad3645)
+++ b/src/chevy/model/entity/dinamicEntity/projectile/Projectile.java	(date 1723037119729)
@@ -37,10 +37,10 @@
     public String toString() { return "PROJECTILE"; }
 
     public enum Type implements CommonEntityType {
-        ARROW, FIRE_BALL, SLIME_SHOT;
+        ARROW, FIRE_BALL, SLIME_SHOT
     }
 
     public enum State implements CommonState {
-        START, LOOP, END;
+        START, LOOP, END
     }
 }
\ No newline at end of file
Index: src/chevy/control/trapsController/SpikedFloorController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chevy.control.trapsController;\n\nimport chevy.control.InteractionType;\nimport chevy.control.PlayerController;\nimport chevy.control.enemyController.EnemyController;\nimport chevy.model.chamber.Chamber;\nimport chevy.model.entity.Entity;\nimport chevy.model.entity.dinamicEntity.liveEntity.enemy.Enemy;\nimport chevy.model.entity.dinamicEntity.liveEntity.player.Player;\nimport chevy.model.entity.staticEntity.environment.traps.SpikedFloor;\n\n/**\n * Controller per gestire le interazioni del giocatore e delle entità con il pavimento spinato nel gioco.\n */\npublic class SpikedFloorController {\n    private final Chamber chamber;\n    private final PlayerController playerController;\n    private final EnemyController enemyController;\n\n    /**\n     * @param chamber la camera di gioco si trova il pavimento spinato\n     */\n    public SpikedFloorController(Chamber chamber, PlayerController playerController, EnemyController enemyController) {\n        this.chamber = chamber;\n        this.playerController = playerController;\n        this.enemyController = enemyController;\n    }\n\n    public void playerInInteraction(SpikedFloor spikedFloor) {\n        playerController.handleInteraction(InteractionType.TRAP, spikedFloor);\n    }\n\n    /**\n     * Aggiorna lo stato del pavimento spinato.\n     *\n     * @param spikedFloor il pavimento spinato da aggiornare\n     */\n    public void update(SpikedFloor spikedFloor) {\n        if (spikedFloor.checkAndChangeState(SpikedFloor.EnumState.ACTIVATED)) {\n            spikedFloor.activated();\n        }\n\n        if (spikedFloor.checkAndChangeState(SpikedFloor.EnumState.DISABLED)) {\n            spikedFloor.disabled();\n        }\n\n        if (spikedFloor.checkAndChangeState(SpikedFloor.EnumState.DAMAGE)) {\n            Entity entity = chamber.getEntityOnTop(spikedFloor);\n            if (entity instanceof Player) {\n                playerController.handleInteraction(InteractionType.TRAP, spikedFloor);\n            }\n            if (entity instanceof Enemy enemy) {\n                enemyController.handleInteraction(InteractionType.TRAP, spikedFloor, enemy);\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/chevy/control/trapsController/SpikedFloorController.java b/src/chevy/control/trapsController/SpikedFloorController.java
--- a/src/chevy/control/trapsController/SpikedFloorController.java	(revision 97aac084825363cf2459bede42d8713076ad3645)
+++ b/src/chevy/control/trapsController/SpikedFloorController.java	(date 1723036631450)
@@ -36,15 +36,15 @@
      * @param spikedFloor il pavimento spinato da aggiornare
      */
     public void update(SpikedFloor spikedFloor) {
-        if (spikedFloor.checkAndChangeState(SpikedFloor.EnumState.ACTIVATED)) {
+        if (spikedFloor.checkAndChangeState(SpikedFloor.State.ACTIVATED)) {
             spikedFloor.activated();
         }
 
-        if (spikedFloor.checkAndChangeState(SpikedFloor.EnumState.DISABLED)) {
+        if (spikedFloor.checkAndChangeState(SpikedFloor.State.DISABLED)) {
             spikedFloor.disabled();
         }
 
-        if (spikedFloor.checkAndChangeState(SpikedFloor.EnumState.DAMAGE)) {
+        if (spikedFloor.checkAndChangeState(SpikedFloor.State.DAMAGE)) {
             Entity entity = chamber.getEntityOnTop(spikedFloor);
             if (entity instanceof Player) {
                 playerController.handleInteraction(InteractionType.TRAP, spikedFloor);
Index: src/chevy/model/entity/staticEntity/environment/traps/SpikedFloor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chevy.model.entity.staticEntity.environment.traps;\n\nimport chevy.model.entity.stateMachine.CommonState;\nimport chevy.model.entity.stateMachine.GlobalState;\nimport chevy.utils.Vector2;\n\npublic class SpikedFloor extends Trap {\n    public enum EnumState implements CommonState {\n        ACTIVATED,\n        DAMAGE,\n        DISABLED\n    }\n    private final GlobalState activated = new GlobalState(EnumState.ACTIVATED, 0.2f);\n    private final GlobalState disabled = new GlobalState(EnumState.DISABLED, 3f);\n    private final GlobalState damage = new GlobalState(EnumState.DAMAGE, 0.8f);\n\n\n    public SpikedFloor(Vector2<Integer> initVelocity) {\n        super(initVelocity, Type.SPIKED_FLOOR);\n        this.safeToCross = true;\n        this.mustBeUpdate = true;\n\n        this.maxDamage = 2;\n        this.minDamage = 1;\n\n        initStateMachine();\n    }\n\n    private void initStateMachine() {\n        stateMachine.setStateMachineName(\"Spiked floor\");\n        stateMachine.setInitialState(disabled);\n\n        disabled.linkState(activated);\n        activated.linkState(damage);\n        damage.linkState(disabled);\n    }\n\n    public void activated() {\n        safeToCross = false;\n    }\n\n    public void disabled() {\n        safeToCross = true;\n    }\n\n    public synchronized GlobalState getState(CommonState commonEnumStates) {\n        EnumState spikedFloorState = (EnumState) commonEnumStates;\n        return switch (spikedFloorState) {\n            case ACTIVATED -> activated;\n            case DISABLED -> disabled;\n            case DAMAGE -> damage;\n        };\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/chevy/model/entity/staticEntity/environment/traps/SpikedFloor.java b/src/chevy/model/entity/staticEntity/environment/traps/SpikedFloor.java
--- a/src/chevy/model/entity/staticEntity/environment/traps/SpikedFloor.java	(revision 97aac084825363cf2459bede42d8713076ad3645)
+++ b/src/chevy/model/entity/staticEntity/environment/traps/SpikedFloor.java	(date 1723036631433)
@@ -5,15 +5,9 @@
 import chevy.utils.Vector2;
 
 public class SpikedFloor extends Trap {
-    public enum EnumState implements CommonState {
-        ACTIVATED,
-        DAMAGE,
-        DISABLED
-    }
-    private final GlobalState activated = new GlobalState(EnumState.ACTIVATED, 0.2f);
-    private final GlobalState disabled = new GlobalState(EnumState.DISABLED, 3f);
-    private final GlobalState damage = new GlobalState(EnumState.DAMAGE, 0.8f);
-
+    private final GlobalState activated = new GlobalState(State.ACTIVATED, 0.2f);
+    private final GlobalState disabled = new GlobalState(State.DISABLED, 3f);
+    private final GlobalState damage = new GlobalState(State.DAMAGE, 0.8f);
 
     public SpikedFloor(Vector2<Integer> initVelocity) {
         super(initVelocity, Type.SPIKED_FLOOR);
@@ -43,12 +37,16 @@
         safeToCross = true;
     }
 
-    public synchronized GlobalState getState(CommonState commonEnumStates) {
-        EnumState spikedFloorState = (EnumState) commonEnumStates;
-        return switch (spikedFloorState) {
+    public synchronized GlobalState getState(CommonState commonState) {
+        State state = (State) commonState;
+        return switch (state) {
             case ACTIVATED -> activated;
             case DISABLED -> disabled;
             case DAMAGE -> damage;
         };
     }
-}
+
+    public enum State implements CommonState {
+        ACTIVATED, DAMAGE, DISABLED
+    }
+}
\ No newline at end of file
Index: src/chevy/model/chamber/Chamber.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chevy.model.chamber;\n\nimport chevy.model.chamber.drawOrder.Layer;\nimport chevy.model.chamber.drawOrder.LayerManager;\nimport chevy.model.entity.Entity;\nimport chevy.model.entity.collectable.Collectable;\nimport chevy.model.entity.dinamicEntity.DirectionsModel;\nimport chevy.model.entity.dinamicEntity.DynamicEntity;\nimport chevy.model.entity.dinamicEntity.liveEntity.enemy.Enemy;\nimport chevy.model.entity.dinamicEntity.liveEntity.enemy.Slime;\nimport chevy.model.entity.dinamicEntity.liveEntity.player.Player;\nimport chevy.model.entity.dinamicEntity.projectile.Projectile;\nimport chevy.model.entity.staticEntity.environment.traps.Trap;\nimport chevy.model.entity.staticEntity.environment.traps.Void;\nimport chevy.model.pathFinding.AStar;\nimport chevy.settings.GameSettings;\nimport chevy.utils.Log;\nimport chevy.utils.Utils;\nimport chevy.utils.Vector2;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\n\n/**\n * L'area di gioco.\n * Gestisce l'inizializzazione della griglia di gioco, il posizionamento e il movimento delle entità.\n */\npublic class Chamber {\n    private final List<Enemy> enemies = new LinkedList<>(); // Nemici nella stanza\n    private final List<Trap> traps = new LinkedList<>(); // Trappole nella stanza\n    private final List<Projectile> projectiles = new LinkedList<>(); // Proiettili nella stanza\n\n    /**\n     * Lista che tiene traccia degli oggetti collezionabili presenti nella stanza.\n     */\n    private final List<Collectable> collectables = new LinkedList<>();\n    /**\n     * Una struttura dati tridimensionale che rappresenta la griglia di gioco.\n     * Ogni cella della griglia può contenere una lista di entità.\n     */\n    private List<List<List<Entity>>> chamber;\n    private LayerManager drawOrderChamber; // Ordine delle in cui le entità vanno disegnate\n    private int nRows; // Righe della griglia di gioco\n    private int nCols; // Colonne della griglia di gioco\n    private boolean init = false; // Indica se il mondo è stato inizializzato\n    private Player player; // Il giocatore attuale\n\n    /**\n     * Inizializza la griglia di gioco con le dimensioni specificate e aggiorna le impostazioni di gioco.\n     *\n     * @param nRow numero di righe che avrà la griglia\n     * @param nCol numero di colonne che avrà la griglia\n     */\n    public void initWorld(int nRow, int nCol) {\n        this.nRows = nRow;\n        this.nCols = nCol;\n        GameSettings.updateValue(nCol, nRow);\n\n        chamber = new ArrayList<>(nRow);\n        for (int i = 0; i < nRow; ++i) {\n            List<List<Entity>> row = new LinkedList<>();\n            for (int j = 0; j < nCol; ++j)\n                row.add(new LinkedList<>());\n            chamber.add(row);\n        }\n\n        drawOrderChamber = new LayerManager();\n        init = true;\n    }\n\n    /**\n     * Verifica se una posizione è valida all'interno della griglia.\n     *\n     * @param vector2 posizione da validare\n     * @return true se valida, false altrimenti\n     */\n    public boolean validatePosition(Vector2<Integer> vector2) {\n        if (init) {\n            return vector2.first >= 0 && vector2.first < nRows && vector2.second >= 0 && vector2.second < nCols;\n        }\n        return false;\n    }\n\n    /**\n     * Verifica se una posizione è valida all'interno della griglia.\n     *\n     * @param row riga da validare\n     * @param col colonna da validare\n     * @return true se è valida, false altrimenti\n     */\n    public boolean validatePosition(int row, int col) {\n        if (init) {\n            return row >= 0 && row < nRows && col >= 0 && col < nCols;\n        }\n        return false;\n    }\n\n    /**\n     * Verifica se la posizione in cui si deve spostare l'entità è valida all'interno della griglia.\n     *\n     * @param entity    entità da considerare\n     * @param direction direzione in cui l'entità si deve muovere\n     * @return true se è valida, false altrimenti\n     */\n    public boolean validatePosition(Entity entity, DirectionsModel direction) {\n        Vector2<Integer> vector2 = new Vector2<>(entity.getRow() + direction.row(), entity.getCol() + direction.col());\n\n        return validatePosition(vector2);\n    }\n\n    /**\n     * Verifica se una determinata cella in una determinata posizione può essere attraversata da un'entità dinamica.\n     *\n     * @param dynamicEntity entità dinamica da considerare.\n     * @param direction     direzione in cui l'entità si deve spostare.\n     * @return true se si può passare, false altrimenti.\n     */\n    public synchronized boolean canCross(DynamicEntity dynamicEntity, DirectionsModel direction) {\n        Vector2<Integer> vector2 = new Vector2<>(dynamicEntity.getRow() + direction.row(),\n                dynamicEntity.getCol() + direction.col());\n\n        return canCross(vector2);\n    }\n\n    /**\n     * Verifica se una determinata cella in una determinata posizione può essere attraversata.\n     *\n     * @param vector2 posizione in cui è presente la cella da controllare\n     * @return true se si può passare, false altrimenti\n     */\n    public synchronized boolean canCross(Vector2<Integer> vector2) {\n        if (validatePosition(vector2)) {\n            List<Entity> entityList = chamber.get(vector2.first).get(vector2.second);\n            for (Entity entity : entityList) {\n                if (!entity.isCrossable()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Verifica se una posizione è sicura da attraversare\n     * (usata principalmente per far si che i nemici non si spostano su celle in cui potrebbero prendere danno).\n     *\n     * @param dynamicEntity entità dinamica considerata\n     * @param direction     direzione in cui si deve spostare\n     * @return true se lo spostamento non danneggerà l'entità dinamica, false altrimenti\n     */\n    public boolean isSafeToCross(DynamicEntity dynamicEntity, DirectionsModel direction) {\n        Vector2<Integer> vector2 = new Vector2<>(dynamicEntity.getRow() + direction.row(),\n                dynamicEntity.getCol() + direction.col());\n        return isSafeToCross(vector2);\n    }\n\n    /**\n     * Verifica se una posizione è sicura da attraversare\n     * (usata principalmente per far si che i nemici non si spostano su celle in cui potrebbero prendere danno).\n     *\n     * @param vector2 posizione della cella da controllare\n     * @return true se lo spostamento non danneggerà l'entità dinamica, false altrimenti\n     */\n    public boolean isSafeToCross(Vector2<Integer> vector2) {\n        Entity onTop = getEntityOnTop(vector2);\n        return canCross(vector2) && onTop.isSafeToCross();\n    }\n\n    /**\n     * Ritorna l'entità in cima alla griglia, situata nella cella in cui si dovrà spostare il player.\n     *\n     * @param dynamicEntity entità dinamica da considerare\n     * @param direction     direzione in cui si deve spostare l'entità dinamica\n     * @return entità in cima alla griglia.\n     */\n    public synchronized Entity getNearEntityOnTop(DynamicEntity dynamicEntity, DirectionsModel direction) {\n        return getNearEntityOnTop(dynamicEntity, direction, 1);\n    }\n\n    /**\n     * Ritorna l'entità in cima alla griglia, situata nella cella in cui si dovrà spostare il player.\n     *\n     * @param dynamicEntity entità dinamica da considerare\n     * @param direction     direzione in cui si deve spostare l'entità dinamica\n     * @param distanceCell  offset che considera le celle più avanti rispetto alla direzione selezionata\n     * @return entità in cima alla griglia\n     */\n    public synchronized Entity getNearEntityOnTop(DynamicEntity dynamicEntity, DirectionsModel direction,\n                                                  int distanceCell) {\n        if (direction == null || dynamicEntity == null) return null;\n\n        Vector2<Integer> vector2 = new Vector2<>(dynamicEntity.getRow() + direction.row() * distanceCell,\n                dynamicEntity.getCol() + direction.col() * distanceCell);\n        if (validatePosition(vector2)) {\n            return getEntityOnTop(vector2);\n        }\n\n        return null;\n    }\n\n    /**\n     * Controlla se un'entità può essere creata in una determinata cella.\n     *\n     * @param vector2 posizione della cella da verificare\n     * @return true se può essere creata, false altrimenti\n     */\n    private synchronized boolean canSpawn(Vector2<Integer> vector2) {\n        Entity onTop = getEntityOnTop(vector2);\n        return validatePosition(vector2) && onTop.isCrossable() && !(onTop instanceof Void);\n    }\n\n    /**\n     * Data un entità ritorna la direzione in cui bisogna avanzare per incontrare il player.\n     *\n     * @param entity entità da considerare per il calcolo della direzione\n     * @return direzione in cui si trova il player\n     */\n    public synchronized DirectionsModel getHitDirectionPlayer(Entity entity) {\n        return getHitDirectionPlayer(entity, 1);\n    }\n\n    /**\n     * Data un entità ritorna la direzione in cui bisogna avanzare per incontrare il player.\n     *\n     * @param entity       entità da considerare per il calcolo della direzione\n     * @param distanceCell offset che considera le celle più avanti rispetto alla direzione selezionata\n     * @return direzione in cui si trova il player\n     */\n    public synchronized DirectionsModel getHitDirectionPlayer(Entity entity, int distanceCell) {\n        DirectionsModel[] directionsModel = DirectionsModel.values();\n\n        for (int i = 1; i <= distanceCell; ++i) {\n            for (DirectionsModel direction : directionsModel) {\n                Vector2<Integer> checkPosition = new Vector2<>(entity.getRow() + direction.row() * i,\n                        entity.getCol() + direction.col() * i);\n                if (validatePosition(checkPosition) && getEntityOnTop(checkPosition) instanceof Player) {\n                    if (entity instanceof DynamicEntity dynamicEntity) {\n                        dynamicEntity.setDirection(direction);\n                    }\n                    return direction;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Sposta un entità dinamica nella cella successiva in corrispondenza della direzione selezionata.\n     *\n     * @param dynamicEntity entità dinamica da spostare\n     * @param direction     direzione in cui l'entità dinamica si deve spostare\n     */\n    public synchronized void moveDynamicEntity(DynamicEntity dynamicEntity, DirectionsModel direction) {\n        Vector2<Integer> nextPosition = new Vector2<>(dynamicEntity.getRow() + direction.row(),\n                dynamicEntity.getCol() + direction.col());\n\n        if (canCross(nextPosition)) {\n            dynamicEntity.setDirection(direction);\n\n            if (findAndRemoveEntity(dynamicEntity)) {\n                dynamicEntity.changePosition(nextPosition);\n                addEntityOnTop(dynamicEntity);\n            }\n        }\n    }\n\n    /**\n     * Sposta un entità dinamica alla cella presente nella posizione data.\n     *\n     * @param dynamicEntity entità dinamica da spostare\n     * @param nextPosition  posizione in cui è presente la cella\n     */\n    public synchronized void moveDynamicEntity(DynamicEntity dynamicEntity, Vector2<Integer> nextPosition) {\n        DirectionsModel direction = DirectionsModel.positionToDirection(new Vector2<>(dynamicEntity.getRow(),\n                dynamicEntity.getCol()), nextPosition);\n\n        if (canCross(nextPosition) && direction != null) {\n            moveDynamicEntity(dynamicEntity, direction);\n        }\n    }\n\n    /**\n     * Trova e rimuove un'entità dalla griglia di gioco.\n     *\n     * @param entity entità da rimuovere\n     * @return true se è stata rimossa, false altrimenti\n     */\n    public synchronized boolean findAndRemoveEntity(Entity entity) {\n        return findAndRemoveEntity(entity, true);\n    }\n\n    /**\n     * Trova e rimuove un'entità dalla griglia di gioco.\n     *\n     * @param entity    entità da rimuovere\n     * @param setToDraw booleana che in base al valore permette all'entità di essere mostrata a schermo\n     * @return true se è stata rimossa, false altrimenti\n     */\n    public synchronized boolean findAndRemoveEntity(Entity entity, boolean setToDraw) {\n        List<Entity> entities = chamber.get(entity.getRow()).get(entity.getCol());\n        ListIterator<Entity> it = entities.listIterator(entities.size());\n        while (it.hasPrevious()) {\n            Entity entity2 = it.previous();\n            if (entity.equals(entity2)) {\n                entity.setToDraw(setToDraw);\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Genera un numero specificato di Slime attorno a un'entità.\n     *\n     * @param entity entità considerata\n     * @param nSlime numero di slime da generare\n     */\n    public synchronized void spawnSlimeAroundEntity(Entity entity, int nSlime) {\n        int f = (int) System.currentTimeMillis(); // fattore che randomizza la posizione\n\n        for (int i = 0; i < 3 && nSlime > 0; ++i) {\n            for (int j = 0; j < 3 && nSlime > 0; ++j) {\n                int randomI = Utils.wrap(f + i, -1, 1);\n                int randomJ = Utils.wrap(f + j, -1, 1);\n\n                if (randomI != 0 || randomJ != 0) {\n                    Vector2<Integer> spawnPosition = new Vector2<>(entity.getRow() + randomI,\n                            entity.getCol() + randomJ);\n                    if (canSpawn(spawnPosition)) {\n                        Slime slime = new Slime(spawnPosition);\n                        addEnemy(slime);\n                        addEntityOnTop(slime);\n                        --nSlime;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Cerca il giocatore in un intervallo quadrato attorno a un'entità.\n     *\n     * @param entity entità da considerare\n     * @param edge   lato del quadrato\n     * @return ritorna il giocatore se presente nell'area, null altrimenti\n     */\n    public synchronized Player findPlayerInSquareRange(Entity entity, int edge) {\n        int startRow = entity.getRow() - edge;\n        int startCol = entity.getCol() - edge;\n        int endRow = entity.getRow() + edge;\n        int endCol = entity.getCol() + edge;\n\n        for (int i = startRow; i <= endRow; ++i) {\n            for (int j = startCol; j <= endCol; ++j) {\n                if (validatePosition(i, j) && getEntityOnTop(i, j) instanceof Player p) {\n                    return p;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Muove in modo casuale il nemico. Il movimento non viene ricalcolato se il movimento precedente non è valido,\n     * as esempio: se la funzione calcola che il nemico si deve spostare a destra dove è presente un muro, il movimento\n     * viene scartato e il nemico non si sposterà.\n     *\n     * @param enemy nemico da spostare\n     * @return true se il nemico è stato spostato, false altrimenti\n     */\n    public synchronized boolean moveRandom(Enemy enemy) {\n        DirectionsModel directionMove = DirectionsModel.getRandom();\n        if (isSafeToCross(enemy, directionMove)) {\n            moveDynamicEntity(enemy, directionMove);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Muove in modo casuale il nemico. Il movimento viene ricalcolato se quello precedente è invalido.\n     * L'operazione viene ripetuta finché non si esauriscono le direzioni disponibili o il nuovo movimento è valido.\n     *\n     * @param enemy nemico da spostare\n     * @return true se il nemico è stato spostato, false altrimenti\n     */\n    public synchronized boolean moveRandomPlus(Enemy enemy) {\n        DirectionsModel[] directions = DirectionsModel.values();\n        Random random = new Random();\n        int index = random.nextInt(directions.length);\n        for (int i = 0; i <= directions.length; ++i) {\n            if (isSafeToCross(enemy, directions[index])) {\n                moveDynamicEntity(enemy, directions[index]);\n                return true;\n            } else {\n                index = Utils.wrap(index + i, 0, directions.length - 1);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Funzione usata per spostare il nemico in modo casuale se il giocatore si trova fuori dall'area quadrata,\n     * altrimenti segue il percorso minore per raggiungere il giocatore. Usa {@link #moveRandom(Enemy)} per il\n     * movimento random.\n     *\n     * @param enemy       nemico da spostare\n     * @param rangeWander lato dell'area del quadrato\n     * @return true se si sposta, false altrimenti\n     */\n    public synchronized boolean wanderChase(Enemy enemy, int rangeWander) {\n        // muoviti verso il player se si trova dentro il tuo campo visivo\n        Player player = findPlayerInSquareRange(enemy, rangeWander);\n        if (player != null) {\n            return chase(enemy);\n        }\n        return moveRandom(enemy);\n    }\n\n    /**\n     * Funzione usata per spostare il nemico in modo casuale se il giocatore si trova fuori dall'area quadrata,\n     * altrimenti segue il percorso minore per raggiungere il giocatore. Usa {@link #moveRandomPlus(Enemy)} per il\n     * movimento random.\n     *\n     * @param enemy       nemico da spostare\n     * @param rangeWander lato dell'area del quadrato\n     * @return true se si sposta, false altrimenti\n     */\n    public synchronized boolean wanderChasePlus(Enemy enemy, int rangeWander) {\n        // muoviti verso il player se si trova dentro il tuo campo visivo\n        Player player = findPlayerInSquareRange(enemy, rangeWander);\n        if (player != null) {\n            return chase(enemy);\n        }\n        // muoviti in modo casuale\n        return moveRandomPlus(enemy);\n    }\n\n    /**\n     * Funzione usata per spostare segundo il percorso minore per raggiungere il giocatore.\n     *\n     * @param enemy nemico da spostare.\n     * @return true se si sposta, false altrimenti.\n     */\n    public synchronized boolean chase(Enemy enemy) {\n        AStar aStar = new AStar(this);\n        List<Vector2<Integer>> path = aStar.find(enemy, player);\n        if (path != null) {\n            if (isSafeToCross(path.get(1))) {\n                moveDynamicEntity(enemy, path.get(1));\n                return true;\n            }\n        }\n        return moveRandom(enemy);\n    }\n\n    public synchronized void removeEntityOnTop(Entity entity) {\n        entity.setToDraw(false);\n        List<Entity> stack = chamber.get(entity.getRow()).get(entity.getCol());\n        try {\n            stack.removeLast();\n        } catch (NoSuchElementException e) {\n            Log.warn(\"Chamber.removeEntityOnTop: la cella è vuota.\");\n        }\n    }\n\n    public synchronized void addEntityOnTop(Entity entity) {\n        chamber.get(entity.getRow()).get(entity.getCol()).addLast(entity);\n        if (!entity.toDraw()) {\n            entity.setToDraw(true);\n            addEntityToDraw(entity, entity.getDrawLayer());\n        }\n    }\n\n    public synchronized Entity getEntityOnTop(int row, int col) { return chamber.get(row).get(col).getLast(); }\n\n    public synchronized Entity getEntityOnTop(Vector2<Integer> vector2) {\n        try {\n            return chamber.get(vector2.first).get(vector2.second).getLast();\n        } catch (NoSuchElementException e) {\n            Log.warn(\"Tentativo di accedere alla cella (\" + vector2.first.toString() + \", \" + vector2.second.toString() + \") fallito perché è vuota\");\n        }\n        return null;\n    }\n\n    public synchronized Entity getEntityOnTop(Entity entity) {\n        return getEntityOnTop(new Vector2<>(entity.getRow(), entity.getCol()));\n    }\n\n    public synchronized Entity getEntityBelowTheTop(Entity entity) {\n        List<Entity> entities = chamber.get(entity.getRow()).get(entity.getCol());\n        int index = entities.size() - 2;\n        return index >= 0 ? entities.get(index) : null;\n    }\n\n    public synchronized List<List<List<Entity>>> getChamber() { return Collections.unmodifiableList(chamber); }\n\n    public boolean isInitialized() { return init; }\n\n    public int getNRows() { return nRows; }\n\n    public int getNCols() { return nCols; }\n\n    public Player getPlayer() { return this.player; }\n\n    public void setPlayer(Player player) { this.player = player; }\n\n    public void addEnemy(Enemy enemy) { this.enemies.add(enemy); }\n\n    public List<Enemy> getEnemies() { return this.enemies; }\n\n    public void addTraps(Trap trap) { traps.add(trap); }\n\n    public List<Trap> getTraps() { return traps; }\n\n    public synchronized void addProjectile(Projectile projectile) { projectiles.add(projectile); }\n\n    public synchronized void addCollectable(Collectable collectable) { collectables.add(collectable); }\n\n    public synchronized List<Collectable> getCollectables() { return collectables; }\n\n    public synchronized List<Projectile> getProjectiles() { return projectiles; }\n\n    public void addEntityToDraw(Entity entity, int layer) { drawOrderChamber.add(entity, layer); }\n\n    public List<Layer> getDrawOrderChamber() { return Collections.unmodifiableList(drawOrderChamber.getDrawOrder()); }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/chevy/model/chamber/Chamber.java b/src/chevy/model/chamber/Chamber.java
--- a/src/chevy/model/chamber/Chamber.java	(revision 97aac084825363cf2459bede42d8713076ad3645)
+++ b/src/chevy/model/chamber/Chamber.java	(date 1723038052820)
@@ -460,6 +460,27 @@
         return moveRandom(enemy);
     }
 
+//    public void show() {
+//        System.out.println();
+//        for (List<List<Entity>> r : chamber) {
+//            for (List<Entity> c : r) {
+//                Entity onTop = getEntityOnTop(c);
+//                if (onTop != null) {
+//                    String a = onTop.toString();
+//                    System.out.print(" | " + a.charAt(0) + a.charAt(1));
+//                }
+//                else {
+//                    System.out.print(" | NULL");
+//                }
+//            }
+//            System.out.println(" |");
+//        }
+//        System.out.println();
+//
+//        System.out.println("Nemici rimanenti: " + enemies);
+//        System.out.println();
+//    }
+
     public synchronized void removeEntityOnTop(Entity entity) {
         entity.setToDraw(false);
         List<Entity> stack = chamber.get(entity.getRow()).get(entity.getCol());
